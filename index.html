<!-- index.html -->
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>日本地図（都道府県）— シンプル版</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
<div id="wrap">
  <canvas id="map"></canvas>
  <div id="hud">ホバーで都道府県名。ホイールでズーム、ドラッグでパン。</div>
</div>
<script src="script.js"></script>
</body>
</html>

/* style.css */
html, body { height: 100%; margin: 0; background: #f7f7fb; }
#wrap { position: relative; height: 100%; }
#map { width: 100%; height: 100%; display: block; background: #ffffff; }
#hud { position: absolute; left: 10px; top: 10px; padding: 8px 10px; background: rgba(255,255,255,.9); border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,.08); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }

// script.js
(async function(){
  const GEOJSON_URL   = './prefectures.json';
  const CAPITALS_URL  = './capitals.json';
  const PADDING       = 20;
  const ZOOM_STEP     = 1.12;

  const canvas = document.getElementById('map');
  const ctx    = canvas.getContext('2d');

  let gj;
  let features = [];
  let bounds   = null;

  // ビュー
  let scale = 1, translateX = 0, translateY = 0;
  let minScale = 25;
  let maxScale = 1000;

  // 選択
  let selectedFeature = null;

  // Pointer Events 状態
  const activePointers = new Map(); // pointerId -> {x,y,type}
  let isPinching = false;
  let pinchStartDist = 0;
  let pinchStartScale = 1;
  let pinchCenterX = 0, pinchCenterY = 0; // CSS px（キャンバス内）

  // パン/タップ判定
  let isPanning = false;
  let lastX = 0, lastY = 0;

  const TAP_MOVE_THRESH = 10;   // px（端末ゆらぎ対策で広め）
  const TAP_TIME_THRESH = 400;  // ms
  let tapStartX = 0, tapStartY = 0, tapStartTime = 0, tapMoved = false;

  // 高DPI & リサイズ
  function resizeCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const w = canvas.clientWidth, h = canvas.clientHeight;
    canvas.width  = Math.round(w * dpr);
    canvas.height = Math.round(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // 描画/ヒット座標は CSS px
    if (ready) draw();
  }
  new ResizeObserver(resizeCanvas).observe(canvas);

  // capitals.json 読み込み（DMS→度）
  const dmsToDeg = (s) => {
    if (typeof s === 'number') return s;
    const [d,m,sec] = String(s).split(':').map(Number);
    return d + (m||0)/60 + (sec||0)/3600;
  };
  let capitalsMap = {}; // { '北海道': { city, lonDeg, latDeg, elev_m } }
  async function loadCapitals(){
    const resp = await fetch(CAPITALS_URL, { cache: 'no-cache' });
    if (!resp.ok) throw new Error('failed to load capitals.json: ' + resp.status);
    const arr = await resp.json();
    capitalsMap = Object.fromEntries(arr.map(row => {
      const lonDeg = dmsToDeg(row.lon_dms ?? row.lon);
      const latDeg = dmsToDeg(row.lat_dms ?? row.lat);
      return [row.pref, { city: row.city, lonDeg, latDeg, elev_m: row.elev_m ?? null }];
    }));
  }

  // データ読込
  let ready = false;
  try {
    const [prefResp] = await Promise.all([
      fetch(GEOJSON_URL, { cache: 'no-cache' }),
      loadCapitals(),
    ]);
    if (!prefResp.ok) throw new Error('failed to load GeoJSON: ' + prefResp.status);
    gj = await prefResp.json();
  } catch (e) { console.error(e); return; }

  // 投影（上下左右修正のため lat 反転）
  const lonLatToXY    = ([lon, lat]) => [lon, -lat];
  const projectCoords = (coords) => (typeof coords[0] === 'number') ? lonLatToXY(coords) : coords.map(projectCoords);

  features = gj.features.map(f => ({ type: f.geometry.type, coords: projectCoords(f.geometry.coordinates), props: f.properties }));

  function computeBounds(){
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    const visit=([x,y])=>{ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; };
    const walk=a=>{ (typeof a[0]==='number') ? visit(a) : a.forEach(walk); };
    features.forEach(f=>walk(f.coords));
    return {minX,minY,maxX,maxY};
  }
  bounds = computeBounds();

  function fitToCanvas(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const worldW = bounds.maxX - bounds.minX;
    const worldH = bounds.maxY - bounds.minY;
    const sx = (w - 2*PADDING) / worldW;
    const sy = (h - 2*PADDING) / worldH;
    scale = Math.min(sx, sy);
    const offsetX = (w - worldW * scale) / 2;
    const offsetY = (h - worldH * scale) / 2;
    translateX = -bounds.minX * scale + offsetX;
    translateY = -bounds.minY * scale + offsetY;
    maxScale = Math.max(500, scale * 10);
  }

  const worldToScreen = ([x,y]) => [x*scale + translateX, y*scale + translateY];

  // ======== 描画 =========
  function drawPolygon(rings){
    ctx.beginPath();
    for(const ring of rings){
      for(let i=0;i<ring.length;i++){
        const [sx,sy] = worldToScreen(ring[i]);
        if (i===0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
      }
      ctx.closePath();
    }
  }

  function ringAreaAndCentroid(ring){
    let A=0, Cx=0, Cy=0, n=ring.length;
    for (let i=0;i<n;i++){
      const [x1,y1]=ring[i], [x2,y2]=ring[(i+1)%n];
      const cross = x1*y2 - x2*y1;
      A  += cross; Cx += (x1+x2)*cross; Cy += (y1+y2)*cross;
    }
    A *= 0.5; if (A===0) return {A:0, cx:ring[0][0], cy:ring[0][1]};
    return {A, cx: Cx/(6*A), cy: Cy/(6*A)};
  }
  function featureCentroid(f){
    if (f.type==='Polygon') { const {cx,cy}=ringAreaAndCentroid(f.coords[0]); return [cx,cy]; }
    let best={area:-Infinity,cx:0,cy:0};
    for(const poly of f.coords){ const {A,cx,cy}=ringAreaAndCentroid(poly[0]); const area=Math.abs(A); if(area>best.area) best={area,cx,cy}; }
    return [best.cx,best.cy];
  }

  function draw(){
    if (!ready) return;
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    for (const f of features){
      const isSel = (f === selectedFeature);
      ctx.fillStyle = isSel ? '#9ad0ff' : '#cfe8ff';
      if (f.type==='Polygon'){ drawPolygon(f.coords); ctx.fill(); ctx.stroke(); }
      else { for(const poly of f.coords){ drawPolygon(poly); ctx.fill(); ctx.stroke(); } }
    }

    // ラベル & 県庁所在地
    if (selectedFeature){
      const name = selectedFeature.props?.N03_001 || '';
      const [cx,cy] = featureCentroid(selectedFeature);
      const [sx,sy] = worldToScreen([cx,cy]);
      ctx.font = 'bold 16px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.lineWidth = 4; ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.strokeText(name, sx, sy);
      ctx.fillStyle = '#1f2937'; ctx.fillText(name, sx, sy);

      const cap = capitalsMap[name];
      if (cap){
        const [px, py] = worldToScreen(lonLatToXY([cap.lonDeg, cap.latDeg]));
        ctx.beginPath(); ctx.arc(px, py, 5, 0, Math.PI*2);
        ctx.fillStyle = '#ffd400'; ctx.fill();
        ctx.lineWidth = 2; ctx.strokeStyle = '#000'; ctx.stroke();
      }
    }
  }

  // ======== ワールド座標でのヒットテスト（DPRや変換のズレを排除） ========
  function pointInRing(wx, wy, ring){
    let inside = false;
    for (let i=0, j=ring.length-1; i<ring.length; j=i++){
      const xi=ring[i][0], yi=ring[i][1];
      const xj=ring[j][0], yj=ring[j][1];
      const intersect = ((yi>wy)!=(yj>wy)) && (wx < (xj - xi) * (wy - yi) / (yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }
  function pointInPolygonRings(wx, wy, rings){
    // GeoJSON: rings[0]=outer, others=holes
    if (!pointInRing(wx, wy, rings[0])) return false;
    for (let h=1; h<rings.length; h++) if (pointInRing(wx, wy, rings[h])) return false;
    return true;
  }
  function hitFeatureAtClient(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const mx = clientX - rect.left, my = clientY - rect.top;     // CSS px
    const wx = (mx - translateX) / scale; // 画面→ワールド
    const wy = (my - translateY) / scale;

    for (const f of features){
      if (f.type==='Polygon'){
        if (pointInPolygonRings(wx, wy, f.coords)) return f;
      } else {
        for (const poly of f.coords){ if (pointInPolygonRings(wx, wy, poly)) return f; }
      }
    }
    return null;
  }

  // ======== アニメーションズーム ========
  function featureBounds(f){
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    const visit=([x,y])=>{ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; };
    const walk=a=>{ (typeof a[0]==='number') ? visit(a) : a.forEach(walk); };
    if (f.type==='Polygon') walk(f.coords); else f.coords.forEach(poly=>walk(poly));
    return {minX,minY,maxX,maxY};
  }
  function zoomToFeatureAnimated(f){
    const fb = featureBounds(f);
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const worldW = fb.maxX - fb.minX, worldH = fb.maxY - fb.minY;
    const pad = Math.max(PADDING, 30);
    let targetScale = Math.min((w - 2*pad) / worldW, (h - 2*pad) / worldH);
    targetScale = Math.max(minScale, Math.min(maxScale, targetScale));
    const offX = (w - worldW * targetScale) / 2;
    const offY = (h - worldH * targetScale) / 2;
    const targetX = -fb.minX * targetScale + offX;
    const targetY = -fb.minY * targetScale + offY;

    const startScale = scale, startX = translateX, startY = translateY;
    const duration = 500; const t0 = performance.now();
    function animate(t){
      const p = Math.min((t - t0) / duration, 1);
      const ease = 1 - Math.pow(1 - p, 3);
      scale      = startScale + (targetScale - startScale) * ease;
      translateX = startX    + (targetX    - startX)    * ease;
      translateY = startY    + (targetY    - startY)    * ease;
      constrainPan(); draw();
      if (p < 1) requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  }

  // ======== Pointer Events（マウス/タッチ統合） ========
  canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    canvas.setPointerCapture(e.pointerId);

    const rect = canvas.getBoundingClientRect();
    activePointers.set(e.pointerId, { x: e.clientX - rect.left, y: e.clientY - rect.top, type: e.pointerType });

    if (activePointers.size === 1) {
      // 1本指（またはマウス）: パン/タップ候補
      isPanning = true; isPinching = false;
      lastX = e.clientX; lastY = e.clientY;
      tapStartX = e.clientX; tapStartY = e.clientY; tapStartTime = performance.now(); tapMoved = false;
    } else if (activePointers.size === 2) {
      // ピンチ開始
      isPanning = false; isPinching = true; tapMoved = true;
      const it = activePointers.values();
      const p1 = it.next().value, p2 = it.next().value;
      pinchStartDist  = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      pinchStartScale = scale;
      const m = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      pinchCenterX = m.x; pinchCenterY = m.y;
    }
  });

  canvas.addEventListener('pointermove', (e) => {
    e.preventDefault(); if (!ready) return;
    const rect = canvas.getBoundingClientRect();
    if (activePointers.has(e.pointerId)) activePointers.set(e.pointerId, { x: e.clientX - rect.left, y: e.clientY - rect.top, type: e.pointerType });

    if (isPinching && activePointers.size >= 2) {
      const it = activePointers.values();
      const p1 = it.next().value, p2 = it.next().value;
      const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      let newScale = Math.max(minScale, Math.min(maxScale, pinchStartScale * (dist / pinchStartDist)));
      const k = newScale / scale;
      translateX = pinchCenterX - (pinchCenterX - translateX) * k;
      translateY = pinchCenterY - (pinchCenterY - translateY) * k;
      scale = newScale; constrainPan(); draw();
    } else if (isPanning && activePointers.size === 1) {
      const dx = e.clientX - lastX, dy = e.clientY - lastY;
      if (Math.abs(e.clientX - tapStartX) > TAP_MOVE_THRESH || Math.abs(e.clientY - tapStartY) > TAP_MOVE_THRESH) tapMoved = true;
      translateX += dx; translateY += dy; lastX = e.clientX; lastY = e.clientY; constrainPan(); draw();
    }
  });

  canvas.addEventListener('pointerup', (e) => {
    e.preventDefault();
    const now = performance.now();
    const wasTap = (!isPinching && activePointers.size <= 1 && !tapMoved && (now - tapStartTime) <= TAP_TIME_THRESH);

    activePointers.delete(e.pointerId);
    if (activePointers.size < 2) isPinching = false;
    if (activePointers.size === 0) isPanning = false;

    if (wasTap) {
      const hit = hitFeatureAtClient(e.clientX, e.clientY);
      if (hit){ selectedFeature = hit; zoomToFeatureAnimated(hit); }
    }
  });

  canvas.addEventListener('pointercancel', (e) => {
    e.preventDefault();
    activePointers.delete(e.pointerId);
    if (activePointers.size < 2) isPinching = false;
    if (activePointers.size === 0) isPanning = false;
    tapMoved = true;
  });

  // ホイールズーム（マウス）
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault(); if (!ready) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    const oldScale = scale;
    const factor = (e.deltaY < 0) ? ZOOM_STEP : (1/ZOOM_STEP);
    const newScale = Math.max(minScale, Math.min(maxScale, scale * factor));
    const k = newScale / oldScale;
    translateX = mx - (mx - translateX) * k;
    translateY = my - (my - translateY) * k;
    scale = newScale; constrainPan(); draw();
  }, { passive:false });

  // 初期表示
  fitToCanvas();
  ready = true;
  resizeCanvas();
})();
